# Microsoft Azure Attestation (MAA) JWT Verification Sample

This is a minimal .NET console application demonstrates how to validate a JWT issued by Microsoft Azure Attestation (MAA).

## How to Verify MAA JWT when MAA is hosted in confidential ACI containers

Sure! Here's the updated description to reflect that the sample also **checks the `iss` (issuer) claim** during token validation:

### Verify that the attestation token is generated by Azure Attestation

Attestation tokens from Azure Attestation are JWTs signed using a certificate chain rooted in a trusted MAA certificate. The token header includes a `jku` (JWK Set URL) parameter, which points to the endpoint hosting the signing certificates. The verifier must retrieve the signing keys from this URL, select the key matching the `kid` in the JWT header, and validate the tokenâ€™s **signature**, **expiration** (optional), and **issuer**.

This ensures the token was not only correctly signed, but also explicitly issued by the expected MAA instance, as indicated by the `iss` claim in the token payload.

The signing certificates are also available via the [OpenID metadata endpoint](https://learn.microsoft.com/en-us/rest/api/attestation/metadata-configuration/get?view=rest-attestation-2022-08-01&tabs=HTTP#get-openid-metadata), for example:  
`https://<your-instance>.attest.azure.net/.well-known/openid-configuration`

See [code](Program.cs#L94) for an implementation example.

### Verify that TEE Kind is SEV-SNP

Verify that the signing certificate contains data indicating that it was issued by a SEV-SNP platform. This is done by checking the TEE Kind X.509 extension in the certificate and confirming that its value corresponds to `sev-snp`. If the extension is missing or the value does not match, the platform is not considered valid.

> Note: If the attestation instance is running on a **general-purpose SKU** or an **SGX-based platform**, the TEE Kind value will differ or may be absent. The sample is currently designed for MAA hosted on a SEV-SNP platform.

See [code](Program.cs#L145) for an implementation example.

### Verify SEVSNP report roots to AMD

The attestation certificate includes the SEV-SNP report and a VCEK certificate chain. The verifier needs to:

- Extract the VCEK certificate chain (in PEM format)
- Parse and validate the certificate chain
- Verify that the chain roots to one of AMD's trusted root keys
- Extract the public ECDSA P-384 key from the leaf certificate
- Verify the signature on the SEV-SNP report using this key

See [code](Program.cs#L187).

### Verify SEVSNP.launchmeasurement equals COSE.launchmeasurement

The COSE UVM endorsement includes a `launchMeasurement` claim. This must match the `measurement` value in the SEV-SNP report. The values are compared byte-for-byte.

See [code](Program.cs#L265).

### Verify PRSS endorsement for UVM image roots to Key-PRSS-ACI

The UVM endorsement is embedded as a COSE_Sign1 structure within an X.509 certificate extension. Verification steps:

- Parse the COSE_Sign1 structure and extract the protected headers and payload.
- Verify the signature of the COSE_Sign1 object.
- Extract the certificate chain (`x5chain`) from the protected headers.
- Ensure the certificate chain is rooted in a trusted PRSS root key.
- If the trusted PRSS anchor requires Enhanced Key Usage (EKU), verify that the signing certificate includes the required EKU and that it matches the expected value.

This step ensures the UVM image is endorsed by a trusted Confidential ACI root.

For more information on the PRSS validation, see [C-ACI documentation](https://github.com/microsoft/confidential-aci-examples/blob/main/docs/Confidential_ACI_SCHEME.md).

See [code](Program.cs#L308) for an implementation example.

### Verify SEVSNP.hostdata matches hash of Rego policy containing Key-PRSS-MAA

The `host_data` field in the SEV-SNP report must be set to the SHA-256 hash of the current policy. This is computed outside the token and compared to the report.

See [code](Program.cs#L395).

### Verify SEVSNP.reportdata matches hash of MAA runtime claims

The lower 32 bytes of the `report_data` field in the SEV-SNP report must equal the SHA-256 hash of the PEM-formatted public key used to sign the JWT. The upper 32 bytes must be all zero. This step proves the attestation is cryptographically bound to the signer.

See [code](Program.cs#L426).

## How to Run

### Prerequisites

- [.NET SDK 8.0+](https://dotnet.microsoft.com/download)
- Internet access
- Attestation instance URL (e.g., `https://instance.attest.azure.net`)

### Clone and Run

```bash
git clone --recursive https://github.com/Azure-Samples/microsoft-azure-attestation.git
cd microsoft-azure-attestation/maa.jwt.verifier.dotnet
dotnet restore
dotnet build
dotnet run
```

This will run the tool using the default JWT token file (`sev-snp-jwt.txt`) and the default DNS name (`https://sharedweu.weu.test.attest.azure.net`).

### To use your own token and expected issuer DNS:

```bash
dotnet run -- <jwt_file> <expected_dns>
```

Example:

```bash
dotnet run -- sev-snp-jwt.txt  https://sharedweu.weu.test.attest.azure.net
```

### Optional: Run in Visual Studio Code

Open the folder in [VS Code](https://code.visualstudio.com/) and press `F5` to start debugging.

## References

- [Microsoft Azure Attestation API](https://github.com/Azure/azure-rest-api-specs/tree/main/specification/attestation/data-plane/Microsoft.Attestation/stable/2022-08-01)
- [Attestation Request Example](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/attestation/data-plane/Microsoft.Attestation/stable/2022-08-01/examples/AttestSevSnpVm.json)
